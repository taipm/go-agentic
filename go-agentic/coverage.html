
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>go-agentic: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/taipm/go-agentic/agent.go (82.0%)</option>
				
				<option value="file1">github.com/taipm/go-agentic/config.go (93.3%)</option>
				
				<option value="file2">github.com/taipm/go-agentic/http.go (60.8%)</option>
				
				<option value="file3">github.com/taipm/go-agentic/report.go (100.0%)</option>
				
				<option value="file4">github.com/taipm/go-agentic/streaming.go (90.9%)</option>
				
				<option value="file5">github.com/taipm/go-agentic/team.go (48.0%)</option>
				
				<option value="file6">github.com/taipm/go-agentic/tests.go (82.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package agentic

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        openai "github.com/openai/openai-go/v3"
        "github.com/openai/openai-go/v3/option"
)

// ExecuteAgent runs an agent and returns its response
func ExecuteAgent(ctx context.Context, agent *Agent, input string, history []Message, apiKey string) (*AgentResponse, error) <span class="cov0" title="0">{
        client := openai.NewClient(option.WithAPIKey(apiKey))

        // Log agent initialization
        fmt.Printf("[INFO] Agent '%s' (ID: %s) using model '%s' with temperature %.1f\n",
                agent.Name, agent.ID, agent.Model, agent.Temperature)

        // Build system prompt
        systemPrompt := buildSystemPrompt(agent)

        // Convert history to openai messages
        messages := buildOpenAIMessages(agent, input, history, systemPrompt)

        // Create completion request
        params := openai.ChatCompletionNewParams{
                Model:    agent.Model,
                Messages: messages,
        }

        // Call OpenAI API
        completion, err := client.Chat.Completions.New(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to call OpenAI API: %w", err)
        }</span>

        <span class="cov0" title="0">if len(completion.Choices) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no choices in completion")
        }</span>

        <span class="cov0" title="0">choice := completion.Choices[0]
        message := choice.Message

        // Extract response content
        content := message.Content

        // Try native tool calls first (official OpenAI API)
        var toolCalls []ToolCall
        if len(message.ToolCalls) &gt; 0 </span><span class="cov0" title="0">{
                toolCalls = parseNativeToolCalls(message.ToolCalls, agent)
        }</span>

        // Fallback to text parsing if no native tool calls
        <span class="cov0" title="0">if len(toolCalls) == 0 </span><span class="cov0" title="0">{
                toolCalls = extractToolCallsFromText(content, agent)
        }</span>

        <span class="cov0" title="0">return &amp;AgentResponse{
                AgentID:   agent.ID,
                AgentName: agent.Name,
                Content:   content,
                ToolCalls: toolCalls,
        }, nil</span>
}

// buildSystemPrompt creates the system prompt for the agent
func buildSystemPrompt(agent *Agent) string <span class="cov8" title="1">{
        // If agent has a custom system prompt, use it (with template variable replacement)
        if agent.SystemPrompt != "" </span><span class="cov8" title="1">{
                prompt := agent.SystemPrompt
                // Replace template variables
                prompt = strings.ReplaceAll(prompt, "{{name}}", agent.Name)
                prompt = strings.ReplaceAll(prompt, "{{role}}", agent.Role)
                prompt = strings.ReplaceAll(prompt, "{{description}}", agent.Name+" - "+agent.Role)
                prompt = strings.ReplaceAll(prompt, "{{backstory}}", agent.Backstory)
                return prompt
        }</span>

        // Otherwise, build a generic prompt
        <span class="cov8" title="1">var prompt strings.Builder

        prompt.WriteString(fmt.Sprintf("You are %s.\n", agent.Name))
        prompt.WriteString(fmt.Sprintf("Role: %s\n", agent.Role))
        prompt.WriteString(fmt.Sprintf("Backstory: %s\n\n", agent.Backstory))

        if len(agent.Tools) &gt; 0 </span><span class="cov8" title="1">{
                prompt.WriteString("You have access to the following tools:\n\n")
                for i, tool := range agent.Tools </span><span class="cov8" title="1">{
                        prompt.WriteString(fmt.Sprintf("%d. %s: %s\n", i+1, tool.Name, tool.Description))
                }</span>

                <span class="cov8" title="1">prompt.WriteString("\nWhen you need to use a tool, use the function calling mechanism.\n")
                prompt.WriteString("The system will handle executing the tool calls you emit.\n")
                prompt.WriteString("Provide tool calls in the proper format and I will execute them for you.\n\n")
                prompt.WriteString("Examples of tools you can call:\n")
                prompt.WriteString("  GetCPUUsage()\n")
                prompt.WriteString("  PingHost(host=\"192.168.1.100\")\n")
                prompt.WriteString("  CheckServiceStatus(service=\"nginx\")\n\n")</span>
        }

        <span class="cov8" title="1">prompt.WriteString("Instructions:\n")
        prompt.WriteString("1. Analyze the input and determine what tools you need\n")
        prompt.WriteString("2. Use tools to gather information\n")
        prompt.WriteString("3. Analyze tool results and provide recommendations\n")
        prompt.WriteString("4. If you need more information, use additional tools\n")

        if agent.IsTerminal </span><span class="cov0" title="0">{
                prompt.WriteString("5. You are the FINAL agent in the workflow - after you respond, the conversation ends\n")
        }</span>

        <span class="cov8" title="1">return prompt.String()</span>
}

// buildOpenAIMessages converts history and input to OpenAI message format
func buildOpenAIMessages(agent *Agent, input string, history []Message, systemPrompt string) []openai.ChatCompletionMessageParamUnion <span class="cov8" title="1">{
        var messages []openai.ChatCompletionMessageParamUnion

        // Add system message
        messages = append(messages, openai.SystemMessage(systemPrompt))

        // Add conversation history
        for _, msg := range history </span><span class="cov8" title="1">{
                switch msg.Role </span>{
                case "user":<span class="cov8" title="1">
                        messages = append(messages, openai.UserMessage(msg.Content))</span>
                case "assistant":<span class="cov8" title="1">
                        messages = append(messages, openai.AssistantMessage(msg.Content))</span>
                case "system":<span class="cov8" title="1">
                        // Tool results and other system messages
                        messages = append(messages, openai.SystemMessage(msg.Content))</span>
                }
        }

        // Add current user input
        <span class="cov8" title="1">messages = append(messages, openai.UserMessage(input))

        return messages</span>
}

// extractToolCallsFromText extracts tool calls from the response text
// This uses a simple regex approach: ToolName(args)
func extractToolCallsFromText(text string, agent *Agent) []ToolCall <span class="cov8" title="1">{
        var calls []ToolCall

        validToolNames := make(map[string]*Tool)
        for _, tool := range agent.Tools </span><span class="cov8" title="1">{
                validToolNames[tool.Name] = tool
        }</span>

        // Look for patterns like: ToolName(...)
        <span class="cov8" title="1">lines := strings.Split(text, "\n")
        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Try to find tool calls in this line
                <span class="cov8" title="1">for toolName := range validToolNames </span><span class="cov8" title="1">{
                        if strings.Contains(line, toolName+"(") </span><span class="cov8" title="1">{
                                // Extract the arguments
                                startIdx := strings.Index(line, toolName+"(")
                                if startIdx != -1 </span><span class="cov8" title="1">{
                                        endIdx := strings.Index(line[startIdx:], ")")
                                        if endIdx != -1 </span><span class="cov8" title="1">{
                                                endIdx += startIdx
                                                argsStr := line[startIdx+len(toolName)+1 : endIdx]

                                                // Parse arguments
                                                args := make(map[string]interface{})
                                                if argsStr != "" </span><span class="cov8" title="1">{
                                                        // Split by comma and trim
                                                        argParts := strings.Split(argsStr, ",")

                                                        // Map positional arguments to named parameters
                                                        tool := validToolNames[toolName]
                                                        paramNames := getToolParameterNames(tool)

                                                        for i, part := range argParts </span><span class="cov8" title="1">{
                                                                part = strings.TrimSpace(part)
                                                                part = strings.Trim(part, `"'`)

                                                                // Use parameter name if available, otherwise use arg0, arg1, etc.
                                                                if i &lt; len(paramNames) </span><span class="cov8" title="1">{
                                                                        args[paramNames[i]] = part
                                                                }</span> else<span class="cov8" title="1"> {
                                                                        args[fmt.Sprintf("arg%d", i)] = part
                                                                }</span>
                                                        }
                                                }

                                                <span class="cov8" title="1">calls = append(calls, ToolCall{
                                                        ID:        fmt.Sprintf("%s_%d", toolName, len(calls)),
                                                        ToolName:  toolName,
                                                        Arguments: args,
                                                })</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">return calls</span>
}

// getToolParameterNames extracts parameter names from tool definition in order
func getToolParameterNames(tool *Tool) []string <span class="cov8" title="1">{
        var paramNames []string

        if tool == nil || tool.Parameters == nil </span><span class="cov8" title="1">{
                return paramNames
        }</span>

        // Extract properties from the tool definition
        <span class="cov8" title="1">if props, ok := tool.Parameters["properties"]; ok </span><span class="cov8" title="1">{
                if propsMap, ok := props.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        // Get required parameters first (in order)
                        if required, ok := tool.Parameters["required"]; ok </span><span class="cov8" title="1">{
                                if requiredList, ok := required.([]string); ok </span><span class="cov8" title="1">{
                                        for _, paramName := range requiredList </span><span class="cov8" title="1">{
                                                if _, exists := propsMap[paramName]; exists </span><span class="cov8" title="1">{
                                                        paramNames = append(paramNames, paramName)
                                                }</span>
                                        }
                                }
                        }

                        // Add optional parameters (those not in required list)
                        <span class="cov8" title="1">requiredSet := make(map[string]bool)
                        if required, ok := tool.Parameters["required"]; ok </span><span class="cov8" title="1">{
                                if requiredList, ok := required.([]string); ok </span><span class="cov8" title="1">{
                                        for _, name := range requiredList </span><span class="cov8" title="1">{
                                                requiredSet[name] = true
                                        }</span>
                                }
                        }

                        // Go through properties in iteration order (maps are unordered, but this is best effort)
                        <span class="cov8" title="1">for paramName := range propsMap </span><span class="cov8" title="1">{
                                if !requiredSet[paramName] </span><span class="cov0" title="0">{
                                        paramNames = append(paramNames, paramName)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return paramNames</span>
}

// parseNativeToolCalls extracts tool calls from OpenAI's native tool_calls field
// This is the official API mechanism for tool calling
func parseNativeToolCalls(nativeToolCalls []openai.ChatCompletionMessageToolCallUnion, agent *Agent) []ToolCall <span class="cov8" title="1">{
        var calls []ToolCall

        validToolNames := make(map[string]*Tool)
        for _, tool := range agent.Tools </span><span class="cov8" title="1">{
                validToolNames[tool.Name] = tool
        }</span>

        <span class="cov8" title="1">for _, nativeCall := range nativeToolCalls </span><span class="cov8" title="1">{
                // Only process function tool calls (not custom tools)
                if nativeCall.Type != "function" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Get function name and arguments
                <span class="cov8" title="1">toolName := nativeCall.Function.Name
                argumentsJSON := nativeCall.Function.Arguments

                // Only process if this is a valid tool for this agent
                if _, isValid := validToolNames[toolName]; !isValid </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Parse arguments from JSON
                <span class="cov8" title="1">args := make(map[string]interface{})
                if argumentsJSON != "" </span><span class="cov8" title="1">{
                        // Parse JSON arguments
                        err := parseJSONArguments(argumentsJSON, args)
                        if err != nil </span><span class="cov0" title="0">{
                                // Log warning but continue - use empty args
                                fmt.Printf("[WARN] Failed to parse JSON arguments for %s: %v\n", toolName, err)
                        }</span>
                }

                <span class="cov8" title="1">calls = append(calls, ToolCall{
                        ID:        nativeCall.ID,
                        ToolName:  toolName,
                        Arguments: args,
                })</span>
        }

        <span class="cov8" title="1">return calls</span>
}

// parseJSONArguments parses JSON argument string into map
func parseJSONArguments(jsonStr string, args map[string]interface{}) error <span class="cov8" title="1">{
        // Use json.Unmarshal to parse the JSON string
        var parsedArgs map[string]interface{}

        // Try to parse as JSON object
        err := json.Unmarshal([]byte(jsonStr), &amp;parsedArgs)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to unmarshal JSON: %w", err)
        }</span>

        // Copy parsed arguments to args map
        <span class="cov8" title="1">for key, value := range parsedArgs </span><span class="cov8" title="1">{
                args[key] = value
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateToolParameters validates tool arguments against the tool's parameter schema
// Returns error if validation fails, nil if validation passes
func validateToolParameters(tool *Tool, arguments map[string]interface{}) error <span class="cov8" title="1">{
        if tool == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("tool is nil")
        }</span>

        // If no parameters defined, no validation needed
        <span class="cov8" title="1">if tool.Parameters == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">requiredParams := extractRequiredParams(tool.Parameters)
        propsSchema := extractPropertiesSchema(tool.Parameters)

        // Check all required parameters are present
        if err := checkRequiredParams(requiredParams, arguments); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Validate each provided argument
        <span class="cov8" title="1">return validateArgumentTypes(propsSchema, arguments)</span>
}

// extractRequiredParams gets the list of required parameter names
func extractRequiredParams(parameters map[string]interface{}) []string <span class="cov8" title="1">{
        var required []string
        if reqList, ok := parameters["required"]; ok </span><span class="cov8" title="1">{
                if reqInterface, ok := reqList.([]interface{}); ok </span><span class="cov8" title="1">{
                        for _, item := range reqInterface </span><span class="cov8" title="1">{
                                if str, ok := item.(string); ok </span><span class="cov8" title="1">{
                                        required = append(required, str)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return required</span>
}

// extractPropertiesSchema gets the properties schema map
func extractPropertiesSchema(parameters map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{
        if props, ok := parameters["properties"]; ok </span><span class="cov8" title="1">{
                if propsMap, ok := props.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        return propsMap
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// checkRequiredParams validates that all required parameters are present
func checkRequiredParams(required []string, arguments map[string]interface{}) error <span class="cov8" title="1">{
        for _, param := range required </span><span class="cov8" title="1">{
                if _, exists := arguments[param]; !exists </span><span class="cov8" title="1">{
                        return fmt.Errorf("missing required parameter: %s", param)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// validateArgumentTypes validates the types of provided arguments
func validateArgumentTypes(propsSchema map[string]interface{}, arguments map[string]interface{}) error <span class="cov8" title="1">{
        for paramName, paramValue := range arguments </span><span class="cov8" title="1">{
                if propsSchema == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">schema, ok := propsSchema[paramName].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if err := validateParameterType(paramName, paramValue, schema); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// validateParameterType validates a single parameter value against its type schema
func validateParameterType(paramName string, paramValue interface{}, paramSchema map[string]interface{}) error <span class="cov8" title="1">{
        // Get the expected type from schema
        paramType, hasType := paramSchema["type"]
        if !hasType </span><span class="cov0" title="0">{
                // No type constraint, validation passes
                return nil
        }</span>

        <span class="cov8" title="1">expectedType, ok := paramType.(string)
        if !ok </span><span class="cov0" title="0">{
                // Type is not a string, can't validate
                return nil
        }</span>

        <span class="cov8" title="1">switch expectedType </span>{
        case "string":<span class="cov8" title="1">
                if _, ok := paramValue.(string); !ok </span><span class="cov8" title="1">{
                        return fmt.Errorf("parameter %s: expected string, got %T", paramName, paramValue)
                }</span>
        case "integer", "number":<span class="cov8" title="1">
                switch paramValue.(type) </span>{
                case float64, int, int32, int64:<span class="cov8" title="1"></span>
                        // Valid numeric types
                default:<span class="cov8" title="1">
                        return fmt.Errorf("parameter %s: expected %s, got %T", paramName, expectedType, paramValue)</span>
                }
        case "boolean":<span class="cov8" title="1">
                if _, ok := paramValue.(bool); !ok </span><span class="cov8" title="1">{
                        return fmt.Errorf("parameter %s: expected boolean, got %T", paramName, paramValue)
                }</span>
        case "array":<span class="cov0" title="0">
                if _, ok := paramValue.([]interface{}); !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("parameter %s: expected array, got %T", paramName, paramValue)
                }</span>
        case "object":<span class="cov0" title="0">
                if _, ok := paramValue.(map[string]interface{}); !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("parameter %s: expected object, got %T", paramName, paramValue)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package agentic

import (
        "fmt"
        "os"
        "path/filepath"

        "gopkg.in/yaml.v3"
)

// ValidateAgentConfig validates an agent configuration
func ValidateAgentConfig(config *AgentConfig) error <span class="cov8" title="1">{
        // Validate Model is not empty
        if config.Model == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("agent config validation failed: Model must be specified (examples: gpt-4o, gpt-4o-mini)")
        }</span>

        // Validate Temperature is in valid range if specified
        <span class="cov8" title="1">if config.Temperature != nil </span><span class="cov8" title="1">{
                temp := *config.Temperature
                if temp &lt; 0.0 || temp &gt; 2.0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("agent config validation failed: Temperature must be between 0.0 and 2.0, got %.1f", temp)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// LoadTeamConfig loads the team configuration from a YAML file
func LoadTeamConfig(path string) (*TeamConfig, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read team config: %w", err)
        }</span>

        <span class="cov8" title="1">var config TeamConfig
        err = yaml.Unmarshal(data, &amp;config)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse team config: %w", err)
        }</span>

        // Set defaults
        <span class="cov8" title="1">if config.Settings.MaxHandoffs == 0 </span><span class="cov8" title="1">{
                config.Settings.MaxHandoffs = 5
        }</span>
        <span class="cov8" title="1">if config.Settings.MaxRounds == 0 </span><span class="cov8" title="1">{
                config.Settings.MaxRounds = 10
        }</span>
        <span class="cov8" title="1">if config.Settings.TimeoutSeconds == 0 </span><span class="cov8" title="1">{
                config.Settings.TimeoutSeconds = 300
        }</span>
        <span class="cov8" title="1">if config.Settings.Language == "" </span><span class="cov8" title="1">{
                config.Settings.Language = "en"
        }</span>

        <span class="cov8" title="1">return &amp;config, nil</span>
}

// LoadAgentConfig loads an agent configuration from a YAML file
func LoadAgentConfig(path string) (*AgentConfig, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read agent config: %w", err)
        }</span>

        <span class="cov8" title="1">var config AgentConfig
        err = yaml.Unmarshal(data, &amp;config)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse agent config: %w", err)
        }</span>

        // Set defaults
        <span class="cov8" title="1">if config.Model == "" </span><span class="cov0" title="0">{
                config.Model = "gpt-4o-mini"
        }</span>
        <span class="cov8" title="1">if config.Temperature == nil </span><span class="cov8" title="1">{
                defaultTemp := 0.7
                config.Temperature = &amp;defaultTemp
        }</span>

        // Validate configuration
        <span class="cov8" title="1">if err := ValidateAgentConfig(&amp;config); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;config, nil</span>
}

// LoadAgentConfigs loads all agent configurations from a directory
func LoadAgentConfigs(dir string) (map[string]*AgentConfig, error) <span class="cov8" title="1">{
        configs := make(map[string]*AgentConfig)

        entries, err := os.ReadDir(dir)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read agent directory: %w", err)
        }</span>

        <span class="cov8" title="1">for _, entry := range entries </span><span class="cov8" title="1">{
                if !entry.IsDir() &amp;&amp; filepath.Ext(entry.Name()) == ".yaml" </span><span class="cov8" title="1">{
                        filePath := filepath.Join(dir, entry.Name())
                        config, err := LoadAgentConfig(filePath)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to load agent config %s: %w", entry.Name(), err)
                        }</span>
                        <span class="cov8" title="1">if config.ID != "" </span><span class="cov8" title="1">{
                                configs[config.ID] = config
                        }</span>
                }
        }

        <span class="cov8" title="1">return configs, nil</span>
}

// CreateAgentFromConfig creates an Agent from an AgentConfig
// Supports tools map for agent creation
func CreateAgentFromConfig(config *AgentConfig, allTools map[string]*Tool) *Agent <span class="cov8" title="1">{
        temperature := 0.7 // default
        if config.Temperature != nil </span><span class="cov8" title="1">{
                temperature = *config.Temperature
        }</span>

        <span class="cov8" title="1">agent := &amp;Agent{
                ID:             config.ID,
                Name:           config.Name,
                Role:           config.Role,
                Backstory:      config.Backstory,
                Model:          config.Model,
                SystemPrompt:   config.SystemPrompt,
                Temperature:    temperature,
                IsTerminal:     config.IsTerminal,
                HandoffTargets: config.HandoffTo,
                Tools:          []*Tool{},
        }

        // Add tools from config
        for _, toolName := range config.Tools </span><span class="cov0" title="0">{
                if tool, exists := allTools[toolName]; exists </span><span class="cov0" title="0">{
                        agent.Tools = append(agent.Tools, tool)
                }</span>
        }

        <span class="cov8" title="1">return agent</span>
}

// Deprecated: Use LoadTeamConfig instead
func LoadCrewConfig(path string) (*TeamConfig, error) <span class="cov8" title="1">{
        return LoadTeamConfig(path)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package agentic

import (
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "sync"
        "time"
)

// StreamRequest represents a request to stream team execution
type StreamRequest struct {
        Query   string    `json:"query"`
        History []Message `json:"history"`
}

// HTTPHandler handles HTTP requests for team execution
type HTTPHandler struct {
        executor *TeamExecutor
        mu       sync.Mutex
}

// NewHTTPHandler creates a new HTTP handler
func NewHTTPHandler(executor *TeamExecutor) *HTTPHandler <span class="cov8" title="1">{
        return &amp;HTTPHandler{
                executor: executor,
        }
}</span>

// StreamHandler handles SSE stream requests
func (h *HTTPHandler) StreamHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Support both GET (EventSource API) and POST methods
        if r.Method != http.MethodGet &amp;&amp; r.Method != http.MethodPost </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Parse request - support both JSON body and query parameter
        <span class="cov8" title="1">var req StreamRequest

        // Try to parse JSON body first (for POST requests)
        if r.Method == http.MethodPost </span><span class="cov8" title="1">{
                if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                        // Fall back to query parameter
                        req.Query = r.URL.Query().Get("q")
                        if req.Query != "" </span><span class="cov0" title="0">{
                                // Try to unmarshal as JSON (from URL encoded JSON)
                                var temp StreamRequest
                                if err := json.Unmarshal([]byte(req.Query), &amp;temp); err == nil </span><span class="cov0" title="0">{
                                        req = temp
                                }</span>
                        }
                }
        } else<span class="cov8" title="1"> {
                // GET request - parse from query parameter
                req.Query = r.URL.Query().Get("q")
                if req.Query != "" </span><span class="cov8" title="1">{
                        // Try to unmarshal as JSON (from URL encoded JSON)
                        var temp StreamRequest
                        if err := json.Unmarshal([]byte(req.Query), &amp;temp); err == nil </span><span class="cov0" title="0">{
                                req = temp
                        }</span>
                }
        }

        <span class="cov8" title="1">if req.Query == "" </span><span class="cov8" title="1">{
                http.Error(w, "Query is required", http.StatusBadRequest)
                return
        }</span>

        // Set up SSE response headers
        <span class="cov8" title="1">w.Header().Set("Content-Type", "text/event-stream")
        w.Header().Set("Cache-Control", "no-cache")
        w.Header().Set("Connection", "keep-alive")
        w.Header().Set("Access-Control-Allow-Origin", "*")

        // Create a channel for streaming events
        streamChan := make(chan *StreamEvent, 10)
        defer close(streamChan)

        // Create a new executor context for this request
        h.mu.Lock()
        executor := h.createRequestExecutor()
        h.mu.Unlock()

        // Restore history if provided
        if len(req.History) &gt; 0 </span><span class="cov8" title="1">{
                executor.history = req.History
        }</span>

        // Run crew execution in a goroutine
        <span class="cov8" title="1">done := make(chan bool)
        var execErr error

        go func() </span><span class="cov8" title="1">{
                execErr = executor.ExecuteStream(r.Context(), req.Query, streamChan)
                done &lt;- true
        }</span>()

        // Send events to client
        <span class="cov8" title="1">flusher, ok := w.(http.Flusher)
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "Streaming not supported", http.StatusInternalServerError)
                return
        }</span>

        // Send opening message
        <span class="cov8" title="1">SendStreamEvent(w, NewStreamEvent("start", "system", "üöÄ Starting crew execution..."))
        flusher.Flush()

        // Event loop
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-done:<span class="cov8" title="1">
                        // Execution completed
                        if execErr != nil </span><span class="cov8" title="1">{
                                SendStreamEvent(w, NewStreamEvent("error", "system", fmt.Sprintf("Execution error: %v", execErr)))
                        }</span> else<span class="cov0" title="0"> {
                                SendStreamEvent(w, NewStreamEvent("done", "system", "‚úÖ Execution completed"))
                        }</span>
                        <span class="cov8" title="1">flusher.Flush()
                        return</span>

                case event := &lt;-streamChan:<span class="cov0" title="0">
                        if event == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">SendStreamEvent(w, event)
                        flusher.Flush()</span>

                case &lt;-time.After(30 * time.Second):<span class="cov0" title="0">
                        // Keep-alive ping
                        SendStreamEvent(w, NewStreamEvent("ping", "system", ""))
                        flusher.Flush()</span>

                case &lt;-r.Context().Done():<span class="cov8" title="1">
                        // Client disconnected
                        log.Println("Client disconnected from stream")
                        return</span>
                }
        }
}

// HealthHandler returns health status
func (h *HTTPHandler) HealthHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{
                "status":  "ok",
                "service": "go-agentic-streaming",
        })
}</span>

// createRequestExecutor creates a new executor for this request
func (h *HTTPHandler) createRequestExecutor() *TeamExecutor <span class="cov8" title="1">{
        return NewTeamExecutor(h.executor.team, h.executor.apiKey)
}</span>

// StartHTTPServer starts the HTTP server with SSE streaming
func StartHTTPServer(executor *TeamExecutor, port int) error <span class="cov0" title="0">{
        handler := NewHTTPHandler(executor)

        http.HandleFunc("/api/crew/stream", handler.StreamHandler)
        http.HandleFunc("/health", handler.HealthHandler)

        // Serve example client
        http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.URL.Path == "/" </span><span class="cov0" title="0">{
                        w.Header().Set("Content-Type", "text/html; charset=utf-8")
                        w.Write([]byte(exampleHTMLClient))
                        return
                }</span>
                <span class="cov0" title="0">http.NotFound(w, r)</span>
        })

        <span class="cov0" title="0">addr := fmt.Sprintf(":%d", port)
        log.Printf("üöÄ HTTP Server starting on http://localhost:%d", port)
        log.Printf("üì° SSE Endpoint: http://localhost:%d/api/crew/stream", port)
        log.Printf("üåê Web Client: http://localhost:%d", port)

        return http.ListenAndServe(addr, nil)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package agentic

import (
        "fmt"
        "strings"
        "time"
)

// HTMLReport generates an HTML test report
type HTMLReport struct {
        TestResults []*TestResult
        GeneratedAt time.Time
        TotalTests  int
        PassedTests int
        FailedTests int
}

// NewHTMLReport creates a new HTML report
func NewHTMLReport(results []*TestResult) *HTMLReport <span class="cov8" title="1">{
        passed := 0
        for _, r := range results </span><span class="cov8" title="1">{
                if r.Passed </span><span class="cov8" title="1">{
                        passed++
                }</span>
        }

        <span class="cov8" title="1">return &amp;HTMLReport{
                TestResults: results,
                GeneratedAt: time.Now(),
                TotalTests:  len(results),
                PassedTests: passed,
                FailedTests: len(results) - passed,
        }</span>
}

// ToHTML generates the complete HTML report
func (r *HTMLReport) ToHTML() string <span class="cov8" title="1">{
        var sb strings.Builder

        sb.WriteString(r.htmlHeader())
        sb.WriteString(r.htmlSummary())
        sb.WriteString(r.htmlTestDetails())
        sb.WriteString(r.htmlFooter())

        return sb.String()
}</span>

func (r *HTMLReport) htmlHeader() string <span class="cov8" title="1">{
        return `&lt;!DOCTYPE html&gt;
&lt;html lang="vi"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;go-agentic Test Report&lt;/title&gt;
    &lt;style&gt;
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            padding: 40px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
        }

        .summary-card {
            background: white;
            padding: 20px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .summary-card h3 {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .summary-card .value {
            font-size: 2.5em;
            font-weight: bold;
            color: #333;
        }

        .summary-card.passed .value {
            color: #28a745;
        }

        .summary-card.failed .value {
            color: #dc3545;
        }

        .summary-card.total .value {
            color: #667eea;
        }

        .timestamp {
            padding: 20px 40px;
            background: white;
            border-bottom: 1px solid #e9ecef;
            font-size: 0.9em;
            color: #666;
        }

        .tests-container {
            padding: 40px;
        }

        .test-case {
            margin-bottom: 30px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .test-case:hover {
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
            border-color: #667eea;
        }

        .test-header {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f8f9fa;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .test-header:hover {
            background: #e9ecef;
        }

        .test-title {
            flex: 1;
        }

        .test-id {
            font-size: 0.85em;
            color: #999;
            margin-right: 15px;
        }

        .test-name {
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }

        .test-desc {
            font-size: 0.9em;
            color: #666;
        }

        .test-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-badge {
            padding: 6px 12px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-badge.passed {
            background: #d4edda;
            color: #155724;
        }

        .status-badge.failed {
            background: #f8d7da;
            color: #721c24;
        }

        .duration {
            font-size: 0.85em;
            color: #999;
            margin-left: 10px;
        }

        .test-body {
            padding: 20px;
            display: none;
            background: white;
            border-top: 1px solid #e9ecef;
        }

        .test-case.expanded .test-body {
            display: block;
        }

        .test-section {
            margin-bottom: 20px;
        }

        .test-section:last-child {
            margin-bottom: 0;
        }

        .section-title {
            font-size: 0.95em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .assertion-list, .error-list, .flow-list {
            list-style: none;
            padding-left: 0;
        }

        .assertion-list li, .error-list li, .flow-list li {
            padding: 8px 12px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            border-radius: 2px;
            font-size: 0.9em;
        }

        .assertion-list li.passed {
            border-left-color: #28a745;
            background: #f0f9f6;
        }

        .assertion-list li.failed {
            border-left-color: #dc3545;
            background: #fdf7f7;
        }

        .error-list li {
            border-left-color: #dc3545;
            background: #fdf7f7;
            color: #721c24;
        }

        .flow-list li {
            display: inline-block;
            background: white;
            border: 1px solid #667eea;
            border-radius: 4px;
            padding: 8px 12px;
            margin-right: 10px;
            margin-bottom: 8px;
            color: #667eea;
            font-weight: 500;
        }

        .flow-list li::after {
            content: ' ‚Üí';
            margin-left: 10px;
        }

        .flow-list li:last-child::after {
            content: '';
        }

        .response-box {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 12px;
            margin-top: 10px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.85em;
            max-height: 200px;
            overflow-y: auto;
            word-break: break-word;
            white-space: pre-wrap;
        }

        .footer {
            background: #f8f9fa;
            padding: 30px 40px;
            text-align: center;
            color: #666;
            font-size: 0.9em;
            border-top: 1px solid #e9ecef;
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 15px;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-item .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .stat-item.passed .dot {
            background: #28a745;
        }

        .stat-item.failed .dot {
            background: #dc3545;
        }

        .stat-item.total .dot {
            background: #667eea;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8em;
            }

            .test-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .test-status {
                margin-top: 10px;
            }

            .summary {
                grid-template-columns: 1fr;
            }
        }

        .toggle-all {
            margin-bottom: 20px;
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s ease;
        }

        .toggle-all:hover {
            background: #5568d3;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
`
}</span>

func (r *HTMLReport) htmlSummary() string <span class="cov8" title="1">{
        passRate := 0
        if r.TotalTests &gt; 0 </span><span class="cov8" title="1">{
                passRate = (r.PassedTests * 100) / r.TotalTests
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf(`
        &lt;div class="header"&gt;
            &lt;h1&gt;üß™ go-agentic Test Report&lt;/h1&gt;
            &lt;p&gt;Intelligent Agent Routing System Test Suite&lt;/p&gt;
        &lt;/div&gt;

        &lt;div class="summary"&gt;
            &lt;div class="summary-card total"&gt;
                &lt;h3&gt;Total Tests&lt;/h3&gt;
                &lt;div class="value"&gt;%d&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="summary-card passed"&gt;
                &lt;h3&gt;Passed&lt;/h3&gt;
                &lt;div class="value"&gt;%d&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="summary-card failed"&gt;
                &lt;h3&gt;Failed&lt;/h3&gt;
                &lt;div class="value"&gt;%d&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="summary-card total"&gt;
                &lt;h3&gt;Pass Rate&lt;/h3&gt;
                &lt;div class="value"&gt;%d%%&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class="timestamp"&gt;
            &lt;strong&gt;Generated:&lt;/strong&gt; %s&lt;br&gt;
            &lt;strong&gt;Test Duration:&lt;/strong&gt; %s
        &lt;/div&gt;
`,
                r.TotalTests,
                r.PassedTests,
                r.FailedTests,
                passRate,
                r.GeneratedAt.Format("2006-01-02 15:04:05"),
                r.getTotalDuration(),
        )</span>
}

func (r *HTMLReport) htmlTestDetails() string <span class="cov8" title="1">{
        var sb strings.Builder

        sb.WriteString(`
        &lt;div class="tests-container"&gt;
            &lt;button class="toggle-all" onclick="toggleAllTests()"&gt;üìÇ Expand/Collapse All Tests&lt;/button&gt;

            &lt;div id="tests"&gt;
`)

        for _, result := range r.TestResults </span><span class="cov8" title="1">{
                sb.WriteString(r.htmlTestCase(result))
        }</span>

        <span class="cov8" title="1">sb.WriteString(`
            &lt;/div&gt;

            &lt;script&gt;
                function toggleAllTests() {
                    const tests = document.querySelectorAll('.test-case');
                    const allExpanded = Array.from(tests).every(t =&gt; t.classList.contains('expanded'));
                    tests.forEach(test =&gt; {
                        if (allExpanded) {
                            test.classList.remove('expanded');
                        } else {
                            test.classList.add('expanded');
                        }
                    });
                }

                // Make test headers clickable
                document.querySelectorAll('.test-header').forEach(header =&gt; {
                    header.addEventListener('click', function() {
                        this.closest('.test-case').classList.toggle('expanded');
                    });
                });
            &lt;/script&gt;
        &lt;/div&gt;
`)

        return sb.String()</span>
}

func (r *HTMLReport) htmlTestCase(result *TestResult) string <span class="cov8" title="1">{
        statusClass := "passed"
        statusText := "‚úì PASSED"
        if !result.Passed </span><span class="cov8" title="1">{
                statusClass = "failed"
                statusText = "‚úó FAILED"
        }</span>

        <span class="cov8" title="1">durationMs := result.Duration.Milliseconds()

        // Build agent response section
        agentResponseHTML := ""
        if result.Response != nil </span><span class="cov8" title="1">{
                agentResponseHTML = fmt.Sprintf(`
                    &lt;!-- Agent Response --&gt;
                    &lt;div class="test-section"&gt;
                        &lt;div class="section-title"&gt;ü§ñ Agent Response (%s - %s)&lt;/div&gt;
                        &lt;div class="response-box"&gt;%s&lt;/div&gt;
                    &lt;/div&gt;
`, result.Response.AgentName, result.Response.AgentID, escapeHTML(result.Response.Content))
        }</span>

        <span class="cov8" title="1">html := fmt.Sprintf(`
            &lt;div class="test-case"&gt;
                &lt;div class="test-header"&gt;
                    &lt;div class="test-title"&gt;
                        &lt;div class="test-id"&gt;Scenario %s&lt;/div&gt;
                        &lt;div class="test-name"&gt;%s&lt;/div&gt;
                        &lt;div class="test-desc"&gt;%s&lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="test-status"&gt;
                        &lt;span class="status-badge %s"&gt;%s&lt;/span&gt;
                        &lt;span class="duration"&gt;%dms&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;

                &lt;div class="test-body"&gt;
                    &lt;!-- User Input --&gt;
                    &lt;div class="test-section"&gt;
                        &lt;div class="section-title"&gt;üìù User Input&lt;/div&gt;
                        &lt;div class="response-box"&gt;%s&lt;/div&gt;
                    &lt;/div&gt;

                    &lt;!-- Expected vs Actual Flow --&gt;
                    &lt;div class="test-section"&gt;
                        &lt;div class="section-title"&gt;üîÑ Agent Flow&lt;/div&gt;
                        &lt;div style="margin-bottom: 10px;"&gt;
                            &lt;strong style="color: #667eea;"&gt;Expected:&lt;/strong&gt;
                            &lt;ul class="flow-list"&gt;
                                %s
                            &lt;/ul&gt;
                        &lt;/div&gt;
                        &lt;div&gt;
                            &lt;strong style="color: #667eea;"&gt;Actual:&lt;/strong&gt;
                            &lt;ul class="flow-list"&gt;
                                %s
                            &lt;/ul&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;

                    %s
`,
                result.Scenario.ID,
                result.Scenario.Name,
                escapeHTML(result.Scenario.Description),
                statusClass,
                statusText,
                durationMs,
                escapeHTML(result.Scenario.UserInput),
                r.htmlFlowList(result.Scenario.ExpectedFlow),
                r.htmlFlowList(result.ActualFlow),
                agentResponseHTML,
        )
        html += `&lt;/div&gt;`

        // Assertions
        if len(result.Scenario.Assertions) &gt; 0 </span><span class="cov8" title="1">{
                html += `
                    &lt;!-- Assertions --&gt;
                    &lt;div class="test-section"&gt;
                        &lt;div class="section-title"&gt;‚úì Assertions&lt;/div&gt;
                        &lt;ul class="assertion-list"&gt;
`
                for _, assertion := range result.Scenario.Assertions </span><span class="cov8" title="1">{
                        html += fmt.Sprintf(`                            &lt;li class="passed"&gt;‚úì %s&lt;/li&gt;`, escapeHTML(assertion))
                }</span>
                <span class="cov8" title="1">html += `
                        &lt;/ul&gt;
                    &lt;/div&gt;
`</span>
        }

        // Errors
        <span class="cov8" title="1">if len(result.Errors) &gt; 0 </span><span class="cov8" title="1">{
                html += `
                    &lt;!-- Errors --&gt;
                    &lt;div class="test-section"&gt;
                        &lt;div class="section-title"&gt;‚ùå Errors&lt;/div&gt;
                        &lt;ul class="error-list"&gt;
`
                for _, errMsg := range result.Errors </span><span class="cov8" title="1">{
                        html += fmt.Sprintf(`                            &lt;li&gt;%s&lt;/li&gt;`, escapeHTML(errMsg))
                }</span>
                <span class="cov8" title="1">html += `
                        &lt;/ul&gt;
                    &lt;/div&gt;
`</span>
        }

        // Warnings
        <span class="cov8" title="1">if len(result.Warnings) &gt; 0 </span><span class="cov8" title="1">{
                html += `
                    &lt;!-- Warnings --&gt;
                    &lt;div class="test-section"&gt;
                        &lt;div class="section-title"&gt;‚ö†Ô∏è Warnings&lt;/div&gt;
                        &lt;ul class="error-list"&gt;
`
                for _, warn := range result.Warnings </span><span class="cov8" title="1">{
                        html += fmt.Sprintf(`                            &lt;li style="color: #856404; border-left-color: #ffc107;"&gt;%s&lt;/li&gt;`, escapeHTML(warn))
                }</span>
                <span class="cov8" title="1">html += `
                        &lt;/ul&gt;
                    &lt;/div&gt;
`</span>
        }

        <span class="cov8" title="1">html += `
                &lt;/div&gt;
            &lt;/div&gt;
`

        return html</span>
}

func (r *HTMLReport) htmlFlowList(flow []string) string <span class="cov8" title="1">{
        if len(flow) == 0 </span><span class="cov8" title="1">{
                return "&lt;li&gt;None&lt;/li&gt;"
        }</span>

        <span class="cov8" title="1">var sb strings.Builder
        for _, agent := range flow </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf("&lt;li&gt;%s&lt;/li&gt;", escapeHTML(agent)))
        }</span>
        <span class="cov8" title="1">return sb.String()</span>
}

func (r *HTMLReport) htmlFooter() string <span class="cov8" title="1">{
        stats := fmt.Sprintf(`
            &lt;div class="stats"&gt;
                &lt;div class="stat-item passed"&gt;
                    &lt;div class="dot"&gt;&lt;/div&gt;
                    &lt;span&gt;%d Passed Tests&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class="stat-item failed"&gt;
                    &lt;div class="dot"&gt;&lt;/div&gt;
                    &lt;span&gt;%d Failed Tests&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class="stat-item total"&gt;
                    &lt;div class="dot"&gt;&lt;/div&gt;
                    &lt;span&gt;%d Total Tests&lt;/span&gt;
                &lt;/div&gt;
            &lt;/div&gt;
`,
                r.PassedTests,
                r.FailedTests,
                r.TotalTests,
        )

        return fmt.Sprintf(`
        &lt;div class="footer"&gt;
            %s
            &lt;p style="margin-top: 15px;"&gt;
                &lt;strong&gt;go-agentic Intelligent Agent Routing System&lt;/strong&gt;&lt;br&gt;
                Tested on: %s&lt;br&gt;
                &lt;small&gt;¬© 2025 Go CrewAI - Smart Multi-Agent IT Support System&lt;/small&gt;
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
`,
                stats,
                time.Now().Format("2006-01-02 15:04:05"),
        )
}</span>

func (r *HTMLReport) getTotalDuration() string <span class="cov8" title="1">{
        var total time.Duration
        for _, result := range r.TestResults </span><span class="cov8" title="1">{
                total += result.Duration
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%dms", total.Milliseconds())</span>
}

// escapeHTML escapes HTML special characters
func escapeHTML(s string) string <span class="cov8" title="1">{
        s = strings.ReplaceAll(s, "&amp;", "&amp;amp;")
        s = strings.ReplaceAll(s, "&lt;", "&amp;lt;")
        s = strings.ReplaceAll(s, "&gt;", "&amp;gt;")
        s = strings.ReplaceAll(s, "\"", "&amp;quot;")
        s = strings.ReplaceAll(s, "'", "&amp;#39;")
        return s
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package agentic

import (
        "encoding/json"
        "fmt"
        "io"
        "time"
)

// FormatStreamEvent formats a StreamEvent as SSE data
// Returns both JSON and plain text formats separated by newlines
func FormatStreamEvent(event *StreamEvent) string <span class="cov8" title="1">{
        // Set timestamp if not already set
        if event.Timestamp.IsZero() </span><span class="cov8" title="1">{
                event.Timestamp = time.Now()
        }</span>

        // Format as JSON
        <span class="cov8" title="1">jsonData, err := json.Marshal(event)
        if err != nil </span><span class="cov0" title="0">{
                jsonData = []byte(`{"type":"error","content":"Failed to marshal event"}`)
        }</span>

        // SSE format: "data: {content}\n\n"
        <span class="cov8" title="1">return fmt.Sprintf("data: %s\n\n", string(jsonData))</span>
}

// SendStreamEvent sends a StreamEvent to the response writer
func SendStreamEvent(w io.Writer, event *StreamEvent) error <span class="cov8" title="1">{
        formatted := FormatStreamEvent(event)
        _, err := fmt.Fprint(w, formatted)
        return err
}</span>

// NewStreamEvent creates a new StreamEvent
func NewStreamEvent(eventType, agent, content string) *StreamEvent <span class="cov8" title="1">{
        return &amp;StreamEvent{
                Type:      eventType,
                Agent:     agent,
                Content:   content,
                Timestamp: time.Now(),
        }
}</span>

// NewStreamEventWithMetadata creates a new StreamEvent with metadata
func NewStreamEventWithMetadata(eventType, agent, content string, metadata interface{}) *StreamEvent <span class="cov8" title="1">{
        return &amp;StreamEvent{
                Type:      eventType,
                Agent:     agent,
                Content:   content,
                Timestamp: time.Now(),
                Metadata:  metadata,
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package agentic

import (
        "context"
        "fmt"
        "strings"
)

// TeamExecutor handles the execution of a team
type TeamExecutor struct {
        team       *Team
        apiKey     string
        entryAgent *Agent
        history    []Message
}

// NewTeamExecutor creates a new team executor
func NewTeamExecutor(team *Team, apiKey string) *TeamExecutor <span class="cov8" title="1">{
        // Find entry agent (first agent that's not terminal)
        var entryAgent *Agent
        for _, agent := range team.Agents </span><span class="cov8" title="1">{
                if !agent.IsTerminal </span><span class="cov8" title="1">{
                        entryAgent = agent
                        break</span>
                }
        }

        <span class="cov8" title="1">return &amp;TeamExecutor{
                team:       team,
                apiKey:     apiKey,
                entryAgent: entryAgent,
                history:    []Message{},
        }</span>
}

// ExecuteStream runs the team with streaming events
func (te *TeamExecutor) ExecuteStream(ctx context.Context, input string, streamChan chan *StreamEvent) error <span class="cov8" title="1">{
        // Add user input to history
        te.history = append(te.history, Message{
                Role:    "user",
                Content: input,
        })

        // Start with entry agent
        currentAgent := te.entryAgent
        if currentAgent == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no entry agent found")
        }</span>

        <span class="cov8" title="1">handoffCount := 0

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                // Send agent start event
                <span class="cov0" title="0">streamChan &lt;- NewStreamEvent("agent_start", currentAgent.Name, fmt.Sprintf("üîÑ Starting %s...", currentAgent.Name))

                // Execute current agent
                response, err := ExecuteAgent(ctx, currentAgent, input, te.history, te.apiKey)
                if err != nil </span><span class="cov0" title="0">{
                        streamChan &lt;- NewStreamEvent("error", currentAgent.Name, fmt.Sprintf("Agent failed: %v", err))
                        return fmt.Errorf("agent %s failed: %w", currentAgent.ID, err)
                }</span>

                // Send agent response event
                <span class="cov0" title="0">streamChan &lt;- NewStreamEvent("agent_response", currentAgent.Name, response.Content)

                // Add agent response to history
                te.history = append(te.history, Message{
                        Role:    "assistant",
                        Content: response.Content,
                })

                // Execute any tool calls BEFORE checking if terminal
                if len(response.ToolCalls) &gt; 0 </span><span class="cov0" title="0">{
                        for _, toolCall := range response.ToolCalls </span><span class="cov0" title="0">{
                                // Send tool start event
                                streamChan &lt;- NewStreamEvent("tool_start", currentAgent.Name,
                                        fmt.Sprintf("üîß [Tool] %s ‚Üí Executing...", toolCall.ToolName))
                        }</span>

                        <span class="cov0" title="0">toolResults := te.executeCalls(ctx, response.ToolCalls, currentAgent)

                        // Send tool results
                        for _, result := range toolResults </span><span class="cov0" title="0">{
                                status := "‚úÖ"
                                if result.Status == "error" </span><span class="cov0" title="0">{
                                        status = "‚ùå"
                                }</span>
                                <span class="cov0" title="0">streamChan &lt;- NewStreamEvent("tool_result", currentAgent.Name,
                                        fmt.Sprintf("%s [Tool] %s ‚Üí %s", status, result.ToolName, result.Output))</span>
                        }

                        // Format results for feedback
                        <span class="cov0" title="0">resultText := formatToolResults(toolResults)

                        // Add results to history with "system" role (tool results are system feedback)
                        te.history = append(te.history, Message{
                                Role:    "system",
                                Content: resultText,
                        })

                        // Feed results back to current agent for analysis
                        input = resultText
                        // Continue loop to let agent process results
                        continue</span>
                }

                // Check if current agent is terminal (only after tool execution)
                <span class="cov0" title="0">if currentAgent.IsTerminal </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Check for routing signals from current agent (config-driven)
                <span class="cov0" title="0">nextAgent := te.findNextAgentBySignal(currentAgent, response.Content)
                if nextAgent != nil </span><span class="cov0" title="0">{
                        currentAgent = nextAgent
                        input = response.Content
                        handoffCount++
                        continue</span>
                }

                // Check if agent waits for signal (from config)
                <span class="cov0" title="0">behavior := te.getAgentBehavior(currentAgent.ID)
                if behavior != nil &amp;&amp; behavior.WaitForSignal </span><span class="cov0" title="0">{
                        // Agent waits for explicit signal, send pause event and stop streaming
                        streamChan &lt;- NewStreamEvent("pause", currentAgent.Name, "[PAUSE] Waiting for user input")
                        return nil
                }</span>

                // For other agents, handoff normally
                <span class="cov0" title="0">handoffCount++
                if handoffCount &gt;= te.team.MaxHandoffs </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Find next agent based on handoff targets
                <span class="cov0" title="0">nextAgent = te.findNextAgent(currentAgent)
                if nextAgent == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">currentAgent = nextAgent
                input = response.Content</span>
        }
}

// Execute runs the team with the given input
func (te *TeamExecutor) Execute(ctx context.Context, input string) (*TeamResponse, error) <span class="cov8" title="1">{
        // Add user input to history
        te.history = append(te.history, Message{
                Role:    "user",
                Content: input,
        })

        // Start with entry agent
        currentAgent := te.entryAgent
        if currentAgent == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no entry agent found")
        }</span>

        <span class="cov0" title="0">handoffCount := 0

        for </span><span class="cov0" title="0">{
                // Execute current agent
                response, err := ExecuteAgent(ctx, currentAgent, input, te.history, te.apiKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("agent %s failed: %w", currentAgent.ID, err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("\n[%s]: %s\n", currentAgent.Name, response.Content)

                // Add agent response to history
                te.history = append(te.history, Message{
                        Role:    "assistant",
                        Content: response.Content,
                })

                // Execute any tool calls BEFORE checking if terminal
                if len(response.ToolCalls) &gt; 0 </span><span class="cov0" title="0">{
                        toolResults := te.executeCalls(ctx, response.ToolCalls, currentAgent)

                        // Format results for feedback
                        resultText := formatToolResults(toolResults)
                        fmt.Println(resultText)

                        // Add results to history with "system" role (tool results are system feedback)
                        te.history = append(te.history, Message{
                                Role:    "system",
                                Content: resultText,
                        })

                        // Feed results back to current agent for analysis
                        input = resultText
                        // Continue loop to let agent process results
                        continue</span>
                }

                // Check if current agent is terminal (only after tool execution)
                <span class="cov0" title="0">if currentAgent.IsTerminal </span><span class="cov0" title="0">{
                        return &amp;TeamResponse{
                                AgentID:    currentAgent.ID,
                                AgentName:  currentAgent.Name,
                                Content:    response.Content,
                                ToolCalls:  response.ToolCalls,
                                IsTerminal: true,
                        }, nil
                }</span>

                // Check for routing signals from current agent (config-driven)
                <span class="cov0" title="0">nextAgent := te.findNextAgentBySignal(currentAgent, response.Content)
                if nextAgent != nil </span><span class="cov0" title="0">{
                        currentAgent = nextAgent
                        input = response.Content
                        handoffCount++
                        continue</span>
                }

                // Check if agent waits for signal (from config)
                <span class="cov0" title="0">behavior := te.getAgentBehavior(currentAgent.ID)
                if behavior != nil &amp;&amp; behavior.WaitForSignal </span><span class="cov0" title="0">{
                        // Agent waits for explicit signal, return and wait for next input
                        return &amp;TeamResponse{
                                AgentID:   currentAgent.ID,
                                AgentName: currentAgent.Name,
                                Content:   response.Content,
                                ToolCalls: response.ToolCalls,
                        }, nil
                }</span>

                // For other agents, handoff normally
                <span class="cov0" title="0">handoffCount++
                if handoffCount &gt;= te.team.MaxHandoffs </span><span class="cov0" title="0">{
                        return &amp;TeamResponse{
                                AgentID:   currentAgent.ID,
                                AgentName: currentAgent.Name,
                                Content:   response.Content,
                                ToolCalls: response.ToolCalls,
                        }, nil
                }</span>

                // Find next agent based on handoff targets
                <span class="cov0" title="0">nextAgent = te.findNextAgent(currentAgent)
                if nextAgent == nil </span><span class="cov0" title="0">{
                        return &amp;TeamResponse{
                                AgentID:   currentAgent.ID,
                                AgentName: currentAgent.Name,
                                Content:   response.Content,
                                ToolCalls: response.ToolCalls,
                        }, nil
                }</span>

                <span class="cov0" title="0">currentAgent = nextAgent
                input = response.Content</span>
        }
}

// executeCalls executes tool calls from an agent
func (te *TeamExecutor) executeCalls(ctx context.Context, calls []ToolCall, agent *Agent) []ToolResult <span class="cov8" title="1">{
        var results []ToolResult

        toolMap := make(map[string]*Tool)
        for _, tool := range agent.Tools </span><span class="cov8" title="1">{
                toolMap[tool.Name] = tool
        }</span>

        <span class="cov8" title="1">for _, call := range calls </span><span class="cov8" title="1">{
                tool, ok := toolMap[call.ToolName]
                if !ok </span><span class="cov8" title="1">{
                        results = append(results, ToolResult{
                                ToolName: call.ToolName,
                                Status:   "error",
                                Output:   fmt.Sprintf("Tool %s not found", call.ToolName),
                        })
                        continue</span>
                }

                // Validate tool parameters before execution
                <span class="cov8" title="1">if validationErr := validateToolParameters(tool, call.Arguments); validationErr != nil </span><span class="cov0" title="0">{
                        results = append(results, ToolResult{
                                ToolName: call.ToolName,
                                Status:   "error",
                                Output:   fmt.Sprintf("Parameter validation failed: %v", validationErr),
                        })
                        continue</span>
                }

                <span class="cov8" title="1">output, err := tool.Handler(ctx, call.Arguments)
                if err != nil </span><span class="cov8" title="1">{
                        results = append(results, ToolResult{
                                ToolName: call.ToolName,
                                Status:   "error",
                                Output:   err.Error(),
                        })
                }</span> else<span class="cov8" title="1"> {
                        results = append(results, ToolResult{
                                ToolName: call.ToolName,
                                Status:   "success",
                                Output:   output,
                        })
                }</span>

                <span class="cov8" title="1">fmt.Printf("[TOOL RESULT] %s: %s\n", call.ToolName, output)</span>
        }

        <span class="cov8" title="1">return results</span>
}

// findAgentByID finds an agent by its ID
func (te *TeamExecutor) findAgentByID(id string) *Agent <span class="cov8" title="1">{
        for _, agent := range te.team.Agents </span><span class="cov8" title="1">{
                if agent.ID == id </span><span class="cov8" title="1">{
                        return agent
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// findNextAgentBySignal finds the next agent based on routing signals (config-driven)
func (te *TeamExecutor) findNextAgentBySignal(current *Agent, responseContent string) *Agent <span class="cov8" title="1">{
        if te.team.Routing == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Get signals defined for current agent in config
        <span class="cov8" title="1">signals, exists := te.team.Routing.Signals[current.ID]
        if !exists || len(signals) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Check which signal is present in the response
        <span class="cov8" title="1">for _, sig := range signals </span><span class="cov8" title="1">{
                if strings.Contains(responseContent, sig.Signal) &amp;&amp; sig.Target != "" </span><span class="cov8" title="1">{
                        // Found matching signal, find the target agent
                        return te.findAgentByID(sig.Target)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// getAgentBehavior retrieves behavior config for an agent
func (te *TeamExecutor) getAgentBehavior(agentID string) *AgentBehavior <span class="cov8" title="1">{
        if te.team.Routing == nil || te.team.Routing.AgentBehaviors == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">behavior, exists := te.team.Routing.AgentBehaviors[agentID]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;behavior</span>
}

// findNextAgent finds the next appropriate agent for handoff
func (te *TeamExecutor) findNextAgent(current *Agent) *Agent <span class="cov8" title="1">{
        // First, try to use handoff_targets from current agent config
        if len(current.HandoffTargets) &gt; 0 </span><span class="cov8" title="1">{
                // Create a map of agents by ID for quick lookup
                agentMap := make(map[string]*Agent)
                for _, agent := range te.team.Agents </span><span class="cov8" title="1">{
                        agentMap[agent.ID] = agent
                }</span>

                // Try to find the first available handoff target
                <span class="cov8" title="1">for _, targetID := range current.HandoffTargets </span><span class="cov8" title="1">{
                        if agent, exists := agentMap[targetID]; exists &amp;&amp; agent.ID != current.ID </span><span class="cov8" title="1">{
                                return agent
                        }</span>
                }
        }

        // Fallback: Find any other agent (not terminal-only strategy)
        <span class="cov8" title="1">for _, agent := range te.team.Agents </span><span class="cov8" title="1">{
                if agent.ID != current.ID </span><span class="cov0" title="0">{
                        return agent
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ToolResult represents the result of executing a tool
type ToolResult struct {
        ToolName string
        Status   string
        Output   string
}

// formatToolResults formats tool results for agent feedback
func formatToolResults(results []ToolResult) string <span class="cov8" title="1">{
        var sb strings.Builder

        sb.WriteString("\n[üìä TOOL EXECUTION RESULTS]\n\n")

        for _, result := range results </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf("%s:\n", result.ToolName))
                sb.WriteString(fmt.Sprintf("  Status: %s\n", result.Status))
                sb.WriteString(fmt.Sprintf("  Output: %s\n\n", result.Output))
        }</span>

        <span class="cov8" title="1">sb.WriteString("[END RESULTS]\n")

        return sb.String()</span>
}

// Deprecated: Use NewTeamExecutor instead
func NewCrewExecutor(team *Team, apiKey string) *TeamExecutor <span class="cov8" title="1">{
        return NewTeamExecutor(team, apiKey)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package agentic

import (
        "context"
        "fmt"
        "strings"
        "time"
)

// TestScenario represents a test case for the crew
type TestScenario struct {
        ID           string
        Name         string
        Description  string
        UserInput    string
        ExpectedFlow []string // Expected agent sequence
        Assertions   []string // Assertions to validate
}

// TestResult tracks the result of a test
type TestResult struct {
        Scenario      *TestScenario
        Passed        bool
        Duration      time.Duration
        ActualFlow    []string
        Response      *TeamResponse
        Errors        []string
        Warnings      []string
        ExecutionLog  string
}

// GetTestScenarios returns all test scenarios
func GetTestScenarios() []*TestScenario <span class="cov8" title="1">{
        return []*TestScenario{
                // Scenario A: Vague Issue
                {
                        ID:   "A",
                        Name: "Vague Issue - Slow Computer",
                        Description: "User reports vague problem without specific server or hostname. " +
                                "System should route to Clarifier for information gathering.",
                        UserInput: "M√°y t√≠nh c·ªßa t√¥i ch·∫≠m l·∫Øm",
                        ExpectedFlow: []string{
                                "clarifier",    // Final agent in flow is Clarifier (Ng√¢n)
                        },
                        Assertions: []string{
                                "Clarifier asks clarifying questions (2-3 questions)",
                                "System returns after Clarifier response (no auto-handoff)",
                                "Response contains question marks indicating need for more info",
                                "Clarifier asks about OS, hardware, recent changes",
                        },
                },

                // Scenario B: Clear Issue with IP
                {
                        ID:   "B",
                        Name: "Clear Issue with Specific IP",
                        Description: "User provides specific server IP and clear problem description. " +
                                "System should route to Executor with explicit routing signal.",
                        UserInput: "Server 192.168.1.50 kh√¥ng ping ƒë∆∞·ª£c, check cho t√¥i",
                        ExpectedFlow: []string{
                                "executor",     // Routes to Executor with IP + problem
                        },
                        Assertions: []string{
                                "Executor runs diagnostic tools on the IP",
                                "Executor provides network diagnostics",
                                "Response contains tool execution results",
                        },
                },

                // Scenario C: Partial Info (Port Issue)
                {
                        ID:   "C",
                        Name: "Specific Problem But Missing Server Info",
                        Description: "User describes specific problem (port 3306) but doesn't specify which server. " +
                                "System should route to Clarifier to get server hostname/IP.",
                        UserInput: "C·ªïng 3306 kh√¥ng open",
                        ExpectedFlow: []string{
                                "clarifier",    // Routes to Clarifier for server identification
                        },
                        Assertions: []string{
                                "Clarifier asks for server hostname/IP",
                                "Clarifier asks about service type on that port",
                                "System returns after Clarifier response (no auto-handoff)",
                        },
                },

                // Scenario D: Network Problem with Location
                {
                        ID:   "D",
                        Name: "Network Problem with Location But No Server",
                        Description: "User reports network issue with location but no specific server. " +
                                "System should ask for clarification.",
                        UserInput: "Kh√¥ng v√†o ƒë∆∞·ª£c internet t·ª´ ph√≤ng A5",
                        ExpectedFlow: []string{
                                "clarifier",    // Routes to Clarifier for details
                        },
                        Assertions: []string{
                                "Clarifier asks which machine or IP",
                                "Clarifier asks about connection type (wired/wireless)",
                                "No auto-handoff to Executor",
                        },
                },

                // Scenario E: Service Status Check with Hostname
                {
                        ID:   "E",
                        Name: "Service Check with Clear Hostname",
                        Description: "User asks to check service status on a specific server by hostname. " +
                                "System routes to Executor with explicit routing signal.",
                        UserInput: "Check xem service MySQL tr√™n server-app-01 c√≤n ch·∫°y kh√¥ng",
                        ExpectedFlow: []string{
                                "executor",     // Routes to Executor with hostname + service check request
                        },
                        Assertions: []string{
                                "Executor runs diagnostic tools on the hostname",
                                "Executor provides service status information",
                                "Response contains tool execution results",
                        },
                },

                // Scenario F: Generic Help Request
                {
                        ID:   "F",
                        Name: "Generic Help Request",
                        Description: "User provides extremely vague request with no context. " +
                                "System should ask for detailed clarification.",
                        UserInput: "Gi√∫p t√¥i check h·ªá th·ªëng",
                        ExpectedFlow: []string{
                                "clarifier",    // Routes to Clarifier
                        },
                        Assertions: []string{
                                "Clarifier provides structured questions (specific problem, OS, etc.)",
                                "System returns waiting for detailed user response",
                                "Response asks about what system and what issues",
                        },
                },

                // Scenario G: CPU Usage Issue with IP
                {
                        ID:   "G",
                        Name: "Performance Issue with IP Address",
                        Description: "User reports high CPU usage with IP address. " +
                                "System routes to Executor with explicit routing signal.",
                        UserInput: "CPU cao tr√™n 192.168.1.100, c·∫ßn ki·ªÉm tra",
                        ExpectedFlow: []string{
                                "executor",     // Routes to Executor with IP + performance issue
                        },
                        Assertions: []string{
                                "Executor runs CPU diagnostic tools",
                                "Executor provides performance analysis",
                                "Response contains tool execution results",
                        },
                },

                // Scenario H: Disk Space with Hostname
                {
                        ID:   "H",
                        Name: "Storage Issue with Hostname",
                        Description: "User reports disk space issue with clear hostname. " +
                                "System routes to Executor with explicit routing signal.",
                        UserInput: "·ªî ƒëƒ©a server-backup kh√¥ng c√≤n ch·ªó, check ngay",
                        ExpectedFlow: []string{
                                "executor",     // Routes to Executor with hostname + urgency keyword
                        },
                        Assertions: []string{
                                "Executor runs disk diagnostic tools",
                                "Executor provides storage analysis",
                                "Response contains tool execution results",
                        },
                },

                // Scenario I: Multiple Affected Systems (Clarification Needed)
                {
                        ID:   "I",
                        Name: "Multiple Systems Issue - Need Clarification",
                        Description: "User reports issue affecting multiple systems but vague. " +
                                "System should ask for clarification about which systems.",
                        UserInput: "H·ªá th·ªëng b·ªã m·∫•t k·∫øt n·ªëi",
                        ExpectedFlow: []string{
                                "clarifier",    // Routes to Clarifier
                        },
                        Assertions: []string{
                                "Clarifier asks which systems are affected",
                                "Clarifier asks about specific machine IPs or names",
                                "Waits for detailed user response",
                        },
                },

                // Scenario J: Already Specific - Multi-Step Diagnosis
                {
                        ID:   "J",
                        Name: "Complete Information - Full Diagnosis",
                        Description: "User provides comprehensive information with IP and multiple issues. " +
                                "System routes to Executor with explicit routing signal.",
                        UserInput: "Server 10.0.0.25 ch·∫°y ch·∫≠m, CPU cao, c·∫ßn check to√†n b·ªô",
                        ExpectedFlow: []string{
                                "executor",     // Routes to Executor with IP + comprehensive diagnostics request
                        },
                        Assertions: []string{
                                "Executor runs comprehensive diagnostic tools",
                                "Executor analyzes multiple system metrics",
                                "Response contains tool execution results",
                        },
                },
        }
}</span>

// RunTestScenario executes a single test scenario
func RunTestScenario(ctx context.Context, scenario *TestScenario, executor *TeamExecutor) *TestResult <span class="cov8" title="1">{
        startTime := time.Now()

        result := &amp;TestResult{
                Scenario:   scenario,
                ActualFlow: []string{},
                Errors:     []string{},
                Warnings:   []string{},
        }

        // Execute the scenario
        response, err := executor.Execute(ctx, scenario.UserInput)
        result.Duration = time.Since(startTime)
        result.Response = response

        if err != nil </span><span class="cov8" title="1">{
                result.Errors = append(result.Errors, fmt.Sprintf("Execution error: %v", err))
                result.Passed = false
                return result
        }</span>

        // Record actual flow
        <span class="cov0" title="0">result.ActualFlow = recordAgentFlow(response)

        // Validate expected flow
        if !validateFlow(scenario.ExpectedFlow, result.ActualFlow) </span><span class="cov0" title="0">{
                result.Errors = append(result.Errors,
                        fmt.Sprintf("Flow mismatch. Expected: %v, Got: %v",
                                scenario.ExpectedFlow, result.ActualFlow))
        }</span>

        // Validate assertions
        <span class="cov0" title="0">validationErrors := validateAssertions(scenario, response, result.ActualFlow)
        result.Errors = append(result.Errors, validationErrors...)

        result.Passed = len(result.Errors) == 0

        return result</span>
}

// recordAgentFlow records which agents responded
func recordAgentFlow(response *TeamResponse) []string <span class="cov8" title="1">{
        var flow []string
        if response != nil </span><span class="cov8" title="1">{
                flow = append(flow, response.AgentID)
        }</span>
        <span class="cov8" title="1">return flow</span>
}

// validateFlow checks if actual flow matches expected
func validateFlow(expected, actual []string) bool <span class="cov8" title="1">{
        if len(expected) != len(actual) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for i := range expected </span><span class="cov8" title="1">{
                if expected[i] != actual[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// validateAssertions validates scenario-specific assertions
func validateAssertions(scenario *TestScenario, response *TeamResponse, flow []string) []string <span class="cov8" title="1">{
        var errors []string

        if response == nil </span><span class="cov8" title="1">{
                errors = append(errors, "Response is nil")
                return errors
        }</span>

        // Validate based on expected flow
        <span class="cov8" title="1">if len(scenario.ExpectedFlow) &gt; 0 </span><span class="cov8" title="1">{
                expectedAgent := scenario.ExpectedFlow[len(scenario.ExpectedFlow)-1]
                if response.AgentID != expectedAgent </span><span class="cov8" title="1">{
                        errors = append(errors, fmt.Sprintf("Scenario %s: Expected %s, got %s", scenario.ID, expectedAgent, response.AgentID))
                }</span>

                // For Clarifier, expect clarifying questions
                <span class="cov8" title="1">if expectedAgent == "clarifier" &amp;&amp; !containsQuestions(response.Content) </span><span class="cov8" title="1">{
                        errors = append(errors, fmt.Sprintf("Scenario %s: Response should contain clarifying questions", scenario.ID))
                }</span>

                // For Executor, expect tool execution or diagnostics
                <span class="cov8" title="1">if expectedAgent == "executor" </span><span class="cov8" title="1">{
                        if !containsAny(response.Content, "TOOL", "GetCPU", "GetMemory", "CheckNetwork", "PingHost", "Ch·∫©n ƒëo√°n") </span><span class="cov0" title="0">{
                                errors = append(errors, fmt.Sprintf("Scenario %s: Executor should show diagnostic output", scenario.ID))
                        }</span>
                }
        }

        <span class="cov8" title="1">return errors</span>
}

// containsQuestions checks if response contains question marks
func containsQuestions(content string) bool <span class="cov8" title="1">{
        return len(content) &gt; 0 &amp;&amp; strings.Contains(content, "?")
}</span>

// containsAny checks if content contains any of the given strings
func containsAny(content string, strs ...string) bool <span class="cov8" title="1">{
        for _, s := range strs </span><span class="cov8" title="1">{
                if strings.Contains(content, s) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
